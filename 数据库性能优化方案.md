# 数据库性能优化方案

## 🔍 问题分析

用户反馈：**正式环境数据加载很慢**，怀疑是数据量太大导致 SQL 查询慢。

## 📊 发现的性能问题

### 1. 缺少关键索引

#### ❌ subscribers 表
- 缺少 `user_id` 字段（严重问题！）
- 缺少 `status` 索引
- 搜索字段 `email`, `first_name`, `last_name` 没有全文索引

#### ❌ campaigns 表
- `status` 字段没有索引（经常用于筛选）
- `scheduled_at` 没有索引（调度器需要）
- `sent_at` 没有索引（排序和筛选）
- `user_id + status` 没有复合索引

#### ❌ campaign_sends 表
- `status` 字段没有单独索引
- `sent_at` 没有索引

#### ❌ list_subscriber 表
- `status` 字段没有索引
- `subscriber_id + status` 没有复合索引

### 2. 代码层面问题

#### ❌ SubscriberController
```php
// 问题 1: 变量未定义
foreach ($items as $subscriber) {  // $items 未定义！
    // ...
}

// 问题 2: whereHas 在大数据量时很慢
$query->whereHas('lists', function ($q) use ($listId) {
    $q->where('lists.id', $listId);
});

// 问题 3: LIKE '%search%' 无法使用索引
$q->where('email', 'like', "%{$search}%")
```

#### ❌ ListController
```php
// 问题: 两次 withCount 产生两个子查询
->withCount([
    'subscribers as subscribers_count' => ...,
    'subscribers as unsubscribed_count' => ...,
])
// 在大数据量时，count(*) 会很慢
```

### 3. 架构问题

**subscribers 表没有 user_id**

当前架构：
```
User -> MailingList -> Subscriber
```

问题：
- 查询某个用户的所有订阅者需要通过列表关联（效率低）
- 无法直接按用户过滤订阅者
- Join 多张表导致查询变慢

建议架构：
```
User -> Subscriber (直接关联)
User -> MailingList -> Subscriber (同时保留列表关联)
```

## ✅ 优化方案

### 方案 1: 添加缺失的索引（立即生效，低风险）

创建迁移文件添加索引：

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        // 1. campaigns 表添加索引
        Schema::table('campaigns', function (Blueprint $table) {
            // 单列索引
            $table->index('status', 'idx_campaigns_status');
            $table->index('scheduled_at', 'idx_campaigns_scheduled_at');
            $table->index('sent_at', 'idx_campaigns_sent_at');
            
            // 复合索引（最常用的查询模式）
            $table->index(['user_id', 'status', 'created_at'], 'idx_campaigns_user_status_time');
        });

        // 2. campaign_sends 表添加索引
        Schema::table('campaign_sends', function (Blueprint $table) {
            $table->index('status', 'idx_campaign_sends_status');
            $table->index('sent_at', 'idx_campaign_sends_sent_at');
            $table->index(['subscriber_id', 'status'], 'idx_campaign_sends_sub_status');
        });

        // 3. list_subscriber 表添加索引
        Schema::table('list_subscriber', function (Blueprint $table) {
            $table->index('status', 'idx_list_subscriber_status');
            $table->index(['list_id', 'status'], 'idx_list_subscriber_list_status');
            $table->index(['subscriber_id', 'status'], 'idx_list_subscriber_sub_status');
        });

        // 4. subscribers 表添加索引
        Schema::table('subscribers', function (Blueprint $table) {
            $table->index('status', 'idx_subscribers_status');
            $table->index('created_at', 'idx_subscribers_created_at');
            
            // 全文索引（用于快速搜索）
            // 注意：需要 MySQL 5.6+ 并且引擎是 InnoDB
            $table->fullText(['email', 'first_name', 'last_name'], 'idx_subscribers_fulltext');
        });
    }

    public function down(): void
    {
        Schema::table('campaigns', function (Blueprint $table) {
            $table->dropIndex('idx_campaigns_status');
            $table->dropIndex('idx_campaigns_scheduled_at');
            $table->dropIndex('idx_campaigns_sent_at');
            $table->dropIndex('idx_campaigns_user_status_time');
        });

        Schema::table('campaign_sends', function (Blueprint $table) {
            $table->dropIndex('idx_campaign_sends_status');
            $table->dropIndex('idx_campaign_sends_sent_at');
            $table->dropIndex('idx_campaign_sends_sub_status');
        });

        Schema::table('list_subscriber', function (Blueprint $table) {
            $table->dropIndex('idx_list_subscriber_status');
            $table->dropIndex('idx_list_subscriber_list_status');
            $table->dropIndex('idx_list_subscriber_sub_status');
        });

        Schema::table('subscribers', function (Blueprint $table) {
            $table->dropIndex('idx_subscribers_status');
            $table->dropIndex('idx_subscribers_created_at');
            $table->dropIndex('idx_subscribers_fulltext');
        });
    }
};
```

**预期效果**：
- ✅ campaigns 列表查询速度提升 50-80%
- ✅ 订阅者筛选速度提升 60-90%
- ✅ 活动发送状态统计速度提升 70%+

### 方案 2: 添加 user_id 到 subscribers 表（高效但需要数据迁移）

#### 步骤 1: 添加字段

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('subscribers', function (Blueprint $table) {
            // 添加 user_id 字段（允许 NULL，稍后填充数据）
            $table->foreignId('user_id')->nullable()->after('id')->constrained()->onDelete('cascade');
            
            // 添加索引
            $table->index(['user_id', 'status'], 'idx_subscribers_user_status');
        });
    }

    public function down(): void
    {
        Schema::table('subscribers', function (Blueprint $table) {
            $table->dropForeign(['user_id']);
            $table->dropIndex('idx_subscribers_user_status');
            $table->dropColumn('user_id');
        });
    }
};
```

#### 步骤 2: 填充数据

创建一个 Artisan 命令来填充 user_id：

```php
<?php

namespace App\Console\Commands;

use App\Models\Subscriber;
use Illuminate\Console\Command;

class FillSubscriberUserId extends Command
{
    protected $signature = 'subscribers:fill-user-id';
    protected $description = 'Fill user_id for existing subscribers based on their lists';

    public function handle()
    {
        $this->info('Starting to fill user_id for subscribers...');

        // 获取所有没有 user_id 的订阅者
        $subscribersWithoutUser = Subscriber::whereNull('user_id')->count();
        $this->info("Found {$subscribersWithoutUser} subscribers without user_id");

        $bar = $this->output->createProgressBar($subscribersWithoutUser);
        $bar->start();

        // 批量处理
        Subscriber::whereNull('user_id')->chunk(1000, function ($subscribers) use ($bar) {
            foreach ($subscribers as $subscriber) {
                // 从第一个关联的列表中获取 user_id
                $list = $subscriber->lists()->first();
                
                if ($list) {
                    $subscriber->update(['user_id' => $list->user_id]);
                } else {
                    // 如果没有关联的列表，可以选择：
                    // 1. 分配给默认用户（第一个用户）
                    // 2. 删除该订阅者
                    // 3. 保持 NULL（稍后手动处理）
                    $this->warn("Subscriber {$subscriber->id} ({$subscriber->email}) has no lists");
                }
                
                $bar->advance();
            }
        });

        $bar->finish();
        $this->info("\nDone!");

        // 报告结果
        $stillNull = Subscriber::whereNull('user_id')->count();
        $filled = $subscribersWithoutUser - $stillNull;
        
        $this->info("Filled user_id for {$filled} subscribers");
        
        if ($stillNull > 0) {
            $this->warn("Still {$stillNull} subscribers without user_id (no associated lists)");
        }
    }
}
```

#### 步骤 3: 修改 user_id 为必填

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('subscribers', function (Blueprint $table) {
            // 将 user_id 改为必填
            $table->foreignId('user_id')->nullable(false)->change();
        });
    }

    public function down(): void
    {
        Schema::table('subscribers', function (Blueprint $table) {
            $table->foreignId('user_id')->nullable()->change();
        });
    }
};
```

#### 步骤 4: 更新 Subscriber 模型

```php
protected $fillable = [
    'user_id',  // ✅ 添加这个
    'email',
    'first_name',
    'last_name',
    'custom_fields',
    'status',
    'subscribed_at',
    'unsubscribed_at',
    'ip_address',
    'source',
];

public function user()
{
    return $this->belongsTo(User::class);
}
```

#### 步骤 5: 优化 SubscriberController

```php
public function index(Request $request)
{
    // ✅ 直接按 user_id 过滤，不再需要 whereHas
    $query = Subscriber::where('user_id', $request->user()->id);

    // Filter by list
    if ($request->has('list_id')) {
        $listId = $request->list_id;
        
        // ✅ 使用 whereExists 替代 whereHas（更快）
        $query->whereExists(function ($q) use ($listId) {
            $q->select(\DB::raw(1))
              ->from('list_subscriber')
              ->whereColumn('list_subscriber.subscriber_id', 'subscribers.id')
              ->where('list_subscriber.list_id', $listId);
        });
        
        // 当按列表过滤时，状态过滤应该使用 list_subscriber.status
        if ($request->has('status')) {
            $query->whereExists(function ($q) use ($listId, $request) {
                $q->select(\DB::raw(1))
                  ->from('list_subscriber')
                  ->whereColumn('list_subscriber.subscriber_id', 'subscribers.id')
                  ->where('list_subscriber.list_id', $listId)
                  ->where('list_subscriber.status', $request->status);
            });
        }
        
        // 加载订阅者在该列表中的状态
        $query->with(['lists' => function ($q) use ($listId) {
            $q->where('lists.id', $listId);
        }]);
    } else {
        // 没有列表过滤时，使用 subscribers.status
        if ($request->has('status')) {
            $query->where('status', $request->status);
        }
    }

    // ✅ 优化搜索：使用全文索引
    if ($request->has('search')) {
        $search = $request->search;
        
        // 如果启用了全文索引
        if (\DB::getDriverName() === 'mysql') {
            $query->whereRaw(
                "MATCH(email, first_name, last_name) AGAINST(? IN BOOLEAN MODE)",
                [$search . '*']
            );
        } else {
            // 后备方案：普通 LIKE 查询
            $query->where(function ($q) use ($search) {
                $q->where('email', 'like', "%{$search}%")
                    ->orWhere('first_name', 'like', "%{$search}%")
                    ->orWhere('last_name', 'like', "%{$search}%");
            });
        }
    }

    $subscribers = $query->latest()->paginate(15);
    
    // ✅ 修复变量名错误
    if ($request->has('list_id')) {
        $items = $subscribers->items();  // ✅ 定义变量
        
        foreach ($items as $subscriber) {
            if ($subscriber->lists->isNotEmpty()) {
                $subscriber->list_status = $subscriber->lists[0]->pivot->status;
                $subscriber->list_unsubscribed_at = $subscriber->lists[0]->pivot->unsubscribed_at;
            } else {
                $subscriber->list_status = 'active';
                $subscriber->list_unsubscribed_at = null;
            }
        }
    }

    return response()->json([
        'data' => $subscribers->items(),
        'meta' => [
            'current_page' => $subscribers->currentPage(),
            'last_page' => $subscribers->lastPage(),
            'per_page' => $subscribers->perPage(),
            'total' => $subscribers->total(),
        ],
    ]);
}
```

**预期效果**：
- ✅ 订阅者列表查询速度提升 **80-95%**
- ✅ 不再需要 join lists 表
- ✅ 全文搜索速度提升 **90%+**

### 方案 3: 优化 ListController

```php
public function index(Request $request)
{
    $lists = MailingList::where('user_id', $request->user()->id)
        // ✅ 使用单个查询获取两个计数
        ->withCount([
            'subscribers' => function ($query) {
                $query->where('list_subscriber.status', 'active')
                      ->orWhere('list_subscriber.status', 'unsubscribed');
            }
        ])
        // ✅ 添加单独的子查询字段
        ->selectRaw('
            (SELECT COUNT(*) FROM list_subscriber 
             WHERE list_subscriber.list_id = lists.id 
             AND list_subscriber.status = "active") as subscribers_count
        ')
        ->selectRaw('
            (SELECT COUNT(*) FROM list_subscriber 
             WHERE list_subscriber.list_id = lists.id 
             AND list_subscriber.status = "unsubscribed") as unsubscribed_count
        ')
        ->latest()
        ->paginate(15);

    return response()->json([
        'data' => $lists->items(),
        'meta' => [
            'current_page' => $lists->currentPage(),
            'last_page' => $lists->lastPage(),
            'per_page' => $lists->perPage(),
            'total' => $lists->total(),
        ],
    ]);
}
```

**或者更好的方案：缓存计数**

```php
// 在 MailingList 模型中添加缓存字段
Schema::table('lists', function (Blueprint $table) {
    $table->integer('active_subscribers_count')->default(0);
    $table->integer('unsubscribed_count')->default(0);
    $table->timestamp('counts_updated_at')->nullable();
});

// 创建一个任务定期更新计数
class UpdateListCountsJob implements ShouldQueue
{
    public function handle()
    {
        MailingList::chunk(100, function ($lists) {
            foreach ($lists as $list) {
                $list->update([
                    'active_subscribers_count' => $list->subscribers()
                        ->wherePivot('status', 'active')
                        ->count(),
                    'unsubscribed_count' => $list->subscribers()
                        ->wherePivot('status', 'unsubscribed')
                        ->count(),
                    'counts_updated_at' => now(),
                ]);
            }
        });
    }
}

// 在订阅者状态变更时更新计数
// 在 Subscriber 模型中添加事件监听
```

### 方案 4: 启用 MySQL 慢查询日志

在服务器上配置 MySQL 慢查询日志：

```bash
# 编辑 MySQL 配置
sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf

# 添加以下配置
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/mysql-slow.log
long_query_time = 1  # 记录执行时间超过1秒的查询
log_queries_not_using_indexes = 1  # 记录没有使用索引的查询

# 重启 MySQL
sudo systemctl restart mysql

# 查看慢查询日志
sudo tail -f /var/log/mysql/mysql-slow.log
```

## 📋 实施计划

### 阶段 1: 快速修复（立即实施，低风险）

**时间**: 30分钟  
**风险**: 低  
**效果**: 50-70% 性能提升

1. ✅ 创建索引迁移（方案 1）
2. ✅ 修复 SubscriberController 中的 `$items` 变量错误
3. ✅ 运行迁移添加索引
4. ✅ 启用慢查询日志

```bash
cd /data/www/sendwalk/backend

# 创建迁移文件
php artisan make:migration add_missing_indexes_for_performance

# 编辑迁移文件（复制上面的代码）
nano database/migrations/YYYY_MM_DD_HHMMSS_add_missing_indexes_for_performance.php

# 运行迁移
php artisan migrate

# 验证索引
php artisan tinker
>>> \DB::select("SHOW INDEX FROM campaigns");
>>> \DB::select("SHOW INDEX FROM subscribers");
>>> \DB::select("SHOW INDEX FROM campaign_sends");
>>> \DB::select("SHOW INDEX FROM list_subscriber");
```

### 阶段 2: 结构优化（计划实施，中风险）

**时间**: 2-3小时  
**风险**: 中（需要数据迁移）  
**效果**: 80-95% 性能提升

1. ⏳ 添加 user_id 到 subscribers 表（方案 2）
2. ⏳ 填充 user_id 数据
3. ⏳ 更新代码使用 user_id 过滤
4. ⏳ 测试所有订阅者相关功能

**建议**：在测试环境先完整测试后再在生产环境实施。

### 阶段 3: 进阶优化（可选）

**时间**: 按需  
**风险**: 低  
**效果**: 进一步提升

1. ⏳ 实施缓存计数（方案 3）
2. ⏳ 添加 Redis 缓存层
3. ⏳ 实施数据库读写分离
4. ⏳ 考虑使用 Elasticsearch 进行全文搜索

## 🧪 性能测试

### 测试前后对比

#### 测试环境
- 数据量: 10万订阅者，1000个列表，100个活动
- 测试工具: Apache Bench (ab)

#### 测试用例

```bash
# 1. 订阅者列表（按用户过滤）
ab -n 100 -c 10 "https://api.sendwalk.com/api/subscribers?list_id=1"

# 2. 活动列表
ab -n 100 -c 10 "https://api.sendwalk.com/api/campaigns"

# 3. 订阅者搜索
ab -n 100 -c 10 "https://api.sendwalk.com/api/subscribers?search=test"

# 4. 列表详情（含计数）
ab -n 100 -c 10 "https://api.sendwalk.com/api/lists"
```

#### 预期结果

| 测试用例 | 优化前 | 优化后（阶段1） | 优化后（阶段2） |
|---------|-------|---------------|---------------|
| 订阅者列表 | 2.5s | 1.0s (-60%) | 0.3s (-88%) |
| 活动列表 | 1.8s | 0.6s (-67%) | 0.5s (-72%) |
| 订阅者搜索 | 5.2s | 2.1s (-60%) | 0.4s (-92%) |
| 列表详情 | 3.1s | 1.5s (-52%) | 0.8s (-74%) |

## ⚠️ 注意事项

### 索引的权衡

**优点**：
- ✅ 查询速度显著提升
- ✅ 对现有代码零影响
- ✅ 立即生效

**缺点**：
- ⚠️ 增加磁盘空间占用（每个索引约占表大小的 10-20%）
- ⚠️ 降低写入性能（约 5-10%）
- ⚠️ 增加内存使用（索引会加载到内存）

**建议**：
- 监控磁盘空间
- 定期清理过期数据（如旧的 send_logs）
- 考虑数据归档策略

### 数据迁移风险

**user_id 迁移的潜在问题**：
1. 订阅者没有关联任何列表 → 需要手动处理
2. 订阅者关联多个不同用户的列表 → 数据不一致，需要清理
3. 迁移过程中服务中断 → 使用数据库事务，准备回滚方案

**缓解措施**：
1. 在测试环境完整测试
2. 准备回滚脚本
3. 在低峰期执行
4. 备份数据库
5. 使用维护模式

```bash
# 进入维护模式
php artisan down --message="数据库优化中，预计15分钟" --retry=60

# 执行迁移
php artisan migrate
php artisan subscribers:fill-user-id

# 退出维护模式
php artisan up
```

## 📈 监控建议

### 1. 查询性能监控

安装 Laravel Telescope（开发/测试环境）：

```bash
composer require laravel/telescope --dev
php artisan telescope:install
php artisan migrate
```

### 2. 数据库性能监控

```bash
# 安装 mysqltuner
sudo apt-get install mysqltuner

# 运行分析
sudo mysqltuner
```

### 3. 应用性能监控（APM）

考虑使用：
- New Relic
- Datadog
- Blackfire.io

## ✅ 总结

### 立即实施（阶段1）
1. ✅ 添加缺失的索引
2. ✅ 修复代码 bug
3. ✅ 启用慢查询日志

**预期效果**: 50-70% 性能提升  
**实施时间**: 30分钟  
**风险**: 低

### 计划实施（阶段2）
1. ⏳ 添加 user_id 到 subscribers
2. ⏳ 优化查询逻辑
3. ⏳ 实施全文搜索

**预期效果**: 80-95% 性能提升  
**实施时间**: 2-3小时  
**风险**: 中

### 可选优化（阶段3）
1. ⏳ 缓存计数
2. ⏳ Redis 缓存层
3. ⏳ 数据归档

**预期效果**: 进一步优化  
**实施时间**: 按需  
**风险**: 低-中

---

**建议**：先实施阶段1（低风险，快速见效），然后根据实际效果决定是否继续阶段2。

