# 页面加载骨架屏优化说明

## 📋 优化目标

- ✅ **数据实时性**：不缓存数据，每次都获取最新数据
- ✅ **流畅体验**：避免白屏，使用骨架屏占位
- ✅ **视觉连续性**：页面结构立即显示，数据异步加载

## 🎯 解决方案

### 1. React Query 配置调整

**位置**: `frontend/src/main.tsx`

```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 0,        // 不缓存，保证数据实时性
      gcTime: 0,           // 不保留垃圾数据
      refetchOnMount: true, // 每次挂载都重新获取
    },
  },
})
```

### 2. 骨架屏组件

**位置**: `frontend/src/components/ui/skeleton.tsx`

创建了一个简单的骨架屏组件，用于显示加载占位符：

```tsx
<Skeleton className="h-4 w-32" />
```

### 3. 页面渲染逻辑优化

**优化前**：
```tsx
if (isLoading && !data) {
  return <div>加载中...</div>  // ❌ 白屏
}

return <div>{/* 页面内容 */}</div>
```

**优化后**：
```tsx
return (
  <div>
    {isLoading || !data ? (
      // ✅ 显示完整页面结构 + 骨架屏
      <Card>
        <Table>
          <TableHeader>{/* 表头 */}</TableHeader>
          <TableBody>
            {[...Array(5)].map((_, i) => (
              <TableRow key={i}>
                <TableCell><Skeleton className="h-4 w-32" /></TableCell>
                {/* 更多骨架屏单元格 */}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </Card>
    ) : data.length === 0 ? (
      // 空状态
    ) : (
      // 实际数据
    )}
  </div>
)
```

## 📦 已优化的页面

### 1. 订阅者管理页面
**文件**: `frontend/src/pages/subscribers/index.tsx`

- ✅ 移除了全屏"加载中..."
- ✅ 显示表格结构 + 5行骨架屏
- ✅ 移除了 `placeholderData`（不再需要缓存）
- ✅ 搜索时也显示骨架屏而不是白屏

### 2. 邮件活动页面
**文件**: `frontend/src/pages/campaigns/index.tsx`

- ✅ 移除了全屏"加载中..."
- ✅ 显示表格结构 + 5行骨架屏
- ✅ 包含所有列：ID、标题、状态、列表、进度、时间、操作

### 3. 邮件列表页面
**文件**: `frontend/src/pages/lists/index.tsx`

- ✅ 移除了全屏"加载中..."
- ✅ 显示表格结构 + 5行骨架屏
- ✅ 包含所有列：ID、标题、订阅者、时间、操作

### 4. 自定义标签页面
**文件**: `frontend/src/pages/tags/index.tsx`

- ✅ 移除了全屏"加载中..."
- ✅ 显示表格结构 + 5行骨架屏
- ✅ 包含所有列：ID、标签名、占位符、值、时间、操作

### 5. 发送监控页面
**文件**: `frontend/src/pages/monitor/index.tsx`

- ✅ 移除了全屏"加载中..."
- ✅ 统计卡片显示 4 个骨架屏卡片
- ✅ 日志区域显示 10 行骨架屏日志行
- ✅ 骨架屏采用终端风格（深色背景）

## 🎨 用户体验对比

### 优化前
```
用户打开页面
    ↓
白屏 + "加载中..."
    ↓
数据加载完成
    ↓
显示内容
```
❌ **体验差**：白屏时间长，不知道页面结构

### 优化后
```
用户打开页面
    ↓
立即显示页面结构 + 骨架屏
    ↓
数据加载完成（后台）
    ↓
骨架屏 → 真实数据（平滑切换）
```
✅ **体验好**：
- 页面结构立即可见
- 用户知道页面在加载什么
- 视觉上更连贯
- 感知加载时间更短

## 🔄 页面加载流程

### 1. 首次打开页面
```
页面挂载
    ↓
isLoading = true, data = undefined
    ↓
显示骨架屏（5行）
    ↓
API 请求
    ↓
数据返回
    ↓
isLoading = false, data = [...]
    ↓
显示真实数据
```

### 2. 搜索/筛选
```
用户输入搜索词
    ↓
queryKey 变化 → 触发新请求
    ↓
isLoading = true
    ↓
显示骨架屏（不是白屏！）
    ↓
新数据返回
    ↓
显示搜索结果
```

### 3. 页面切换
```
从 A 页面切换到 B 页面
    ↓
B 页面挂载
    ↓
isLoading = true
    ↓
显示骨架屏
    ↓
数据加载
    ↓
显示内容
```

## 💡 技术细节

### 骨架屏数量
默认显示 **5行**骨架屏：
```tsx
{[...Array(5)].map((_, i) => (
  <TableRow key={i}>
    {/* 骨架屏单元格 */}
  </TableRow>
))}
```

可以根据实际需要调整行数。

### 骨架屏样式
- **宽度**：根据列内容设置不同宽度（如 `w-12`, `w-32`, `w-40`）
- **高度**：通常使用 `h-4`（文本）或 `h-6`/`h-8`（按钮/徽章）
- **动画**：自带 `animate-pulse` 脉冲动画
- **对齐**：使用 `mx-auto`（居中）或 `ml-auto`（右对齐）

### 判断逻辑
```tsx
isLoading || !data
```
- `isLoading`：API 正在请求
- `!data`：数据尚未返回

两者满足其一，就显示骨架屏。

## 🚀 部署步骤

```bash
# 1. 进入前端目录
cd /data/www/sendwalk/frontend

# 2. 构建
npm run build

# 3. 重载 Nginx
sudo nginx -t
sudo nginx -s reload
```

## ✅ 验证效果

### 1. 打开浏览器开发者工具
- Network 标签，设置网络速度为 "Slow 3G"

### 2. 访问页面
- 订阅者管理：`https://edm.sendwalk.com/lists/1/subscribers`
- 邮件活动：`https://edm.sendwalk.com/campaigns`
- 邮件列表：`https://edm.sendwalk.com/lists`
- 自定义标签：`https://edm.sendwalk.com/tags`

### 3. 观察
- ✅ 页面立即显示表格结构
- ✅ 骨架屏有脉冲动画
- ✅ 数据加载后平滑切换
- ✅ 搜索时也显示骨架屏，不是白屏

## 📊 性能对比

### 感知加载时间
- **优化前**：用户看到白屏，直到数据加载完成（如 2秒）
- **优化后**：用户立即看到页面结构（<100ms），数据加载是渐进式的

### 用户体验评分
- **优化前**：⭐⭐ (白屏体验差)
- **优化后**：⭐⭐⭐⭐⭐ (流畅、专业)

## 🎯 总结

### 优势
1. ✅ **数据实时**：不缓存，每次都是最新数据
2. ✅ **无白屏**：页面结构立即可见
3. ✅ **视觉连续**：骨架屏 → 数据的平滑过渡
4. ✅ **专业感**：符合现代 Web 应用最佳实践

### 适用场景
- ✅ 需要实时数据的管理后台
- ✅ 数据经常变化的页面
- ✅ 用户需要频繁刷新的场景

### 不适用场景
- ❌ 数据几乎不变的静态页面（可以用缓存）
- ❌ 数据量特别大的页面（可能需要虚拟滚动）

---

**最佳实践**：先显示结构，再填充数据，让用户始终知道页面在做什么。

