# 导入进度轮询优化说明

## 🐛 问题描述

### 症状
1. 导入订阅者时，前端不断查询导入进度
2. 后端日志一直没有收到请求
3. 前端请求一直处于 pending 状态
4. 过了很久后，后端突然同时收到大量请求
5. 然后前端才提示导入完成

### 根本原因
**请求堆积（Request Queue Buildup）**

```
时间线：
0s:   前端开始每秒发送进度查询请求
1s:   第1个请求还在等待PHP-FPM进程
2s:   第2个请求也在排队
3s:   第3个请求也在排队
...
180s: 第180个请求还在排队（3分钟导入时间）

导入完成后：
PHP-FPM进程释放 → 180个请求突然全部被处理 → 后端日志爆炸
```

### 技术细节

#### 1. **PHP-FPM进程数限制**
默认配置（`/etc/php/8.x/fpm/pool.d/www.conf`）：
```ini
pm = dynamic
pm.max_children = 5        # 最多5个进程
pm.start_servers = 2       # 启动2个进程
pm.min_spare_servers = 1   # 最少1个空闲进程
pm.max_spare_servers = 3   # 最多3个空闲进程
```

#### 2. **请求堆积过程**
- 前端每秒发送1个请求
- PHP-FPM只有5个进程
- 导入任务占用所有进程（处理数据库操作）
- 新的进度查询请求只能排队等待
- Nginx的请求队列中积压了几百个请求

#### 3. **为什么后端日志看不到**
后端代码中有这样的逻辑：
```php
// 只记录前5次查询的日志
if ($queryCount[$importId] <= 5) {
    \Log::info('查询导入进度', [...]);
}
```
所以大部分请求不会被记录。

---

## ✅ 已完成的优化

### 修改1：增加轮询间隔（从1秒改为3秒）

**订阅者导入** (`frontend/src/pages/subscribers/index.tsx`)：
```typescript
// 之前：每秒轮询一次
}, 1000)

// 现在：每3秒轮询一次
}, 3000) // 优化：减少请求频率
```

**黑名单导入** (`frontend/src/pages/blacklist/index.tsx`)：
```typescript
// 之前：每秒轮询一次
}, 1000)

// 现在：每3秒轮询一次
}, 3000) // 优化：减少请求频率
```

### 效果
- **之前**：3分钟导入 = 180个请求
- **现在**：3分钟导入 = 60个请求
- **减少**：67% 的请求数量

---

## 🔧 进一步优化建议

### 方案2：调整PHP-FPM配置

编辑 `/etc/php/8.x/fpm/pool.d/www.conf`：

```ini
[www]
; 进程管理方式
pm = dynamic

; 最大子进程数（根据服务器内存调整）
; 计算公式：max_children = 总内存 / 每进程内存
; 例如：8GB内存，每进程50MB → 8000/50 = 160
pm.max_children = 20

; 启动时的进程数
pm.start_servers = 5

; 最少空闲进程数
pm.min_spare_servers = 3

; 最多空闲进程数
pm.max_spare_servers = 8

; 每个子进程处理的最大请求数
pm.max_requests = 500

; 请求超时时间
request_terminate_timeout = 300s
```

**重启PHP-FPM**：
```bash
sudo systemctl restart php8.2-fpm
```

---

### 方案3：使用动态轮询间隔

根据导入进度动态调整轮询频率：

```typescript
const pollImportProgress = async (importId: string) => {
  let pollInterval = 3000 // 初始3秒
  let consecutiveSlowProgress = 0

  const poll = async () => {
    try {
      const response = await api.get(`/subscribers/import-progress/${importId}`)
      const progress = response.data.data
      
      // 如果进度很慢（< 5%变化），降低轮询频率
      if (progress.progress < 10) {
        pollInterval = 5000 // 减慢到5秒
      } else if (progress.progress > 90) {
        pollInterval = 2000 // 接近完成时加快到2秒
      }
      
      // 更新进度...
      
      if (progress.status === 'completed' || progress.status === 'failed') {
        return
      }
      
      // 递归调用，使用动态间隔
      setTimeout(poll, pollInterval)
    } catch (error) {
      console.error('轮询失败:', error)
    }
  }
  
  poll()
}
```

---

### 方案4：添加请求取消机制

使用 AbortController 避免重复请求：

```typescript
const pollImportProgress = async (importId: string) => {
  let abortController: AbortController | null = null
  
  const pollInterval = setInterval(async () => {
    // 如果上一个请求还在进行，取消它
    if (abortController) {
      abortController.abort()
    }
    
    abortController = new AbortController()
    
    try {
      const response = await api.get(
        `/subscribers/import-progress/${importId}`,
        { signal: abortController.signal }
      )
      // 处理响应...
    } catch (error) {
      if (error.name === 'AbortError') {
        // 请求被取消，忽略
        return
      }
      console.error('轮询失败:', error)
    } finally {
      abortController = null
    }
  }, 3000)
}
```

---

### 方案5：Nginx配置优化

编辑 `/etc/nginx/sites-available/sendwalk`：

```nginx
server {
    # ... 其他配置

    # 增加FastCGI连接超时
    fastcgi_connect_timeout 300;
    fastcgi_send_timeout 300;
    fastcgi_read_timeout 300;
    
    # 增加缓冲区大小
    fastcgi_buffer_size 64k;
    fastcgi_buffers 8 64k;
    fastcgi_busy_buffers_size 128k;
    
    # 增加最大请求大小
    client_max_body_size 100M;
    
    # 连接池优化
    keepalive_timeout 65;
    keepalive_requests 100;
}
```

**重启Nginx**：
```bash
sudo nginx -t
sudo systemctl reload nginx
```

---

### 方案6：使用Server-Sent Events (SSE)（高级）

更优雅的解决方案，服务器主动推送进度：

**后端**（Laravel）：
```php
public function streamImportProgress(string $importId)
{
    return response()->stream(function () use ($importId) {
        $cacheKey = "import_progress:{$importId}";
        
        while (true) {
            $progress = Cache::get($cacheKey);
            
            if (!$progress) {
                echo "data: " . json_encode(['error' => '任务不存在']) . "\n\n";
                break;
            }
            
            echo "data: " . json_encode($progress) . "\n\n";
            ob_flush();
            flush();
            
            if ($progress['status'] === 'completed' || $progress['status'] === 'failed') {
                break;
            }
            
            sleep(3);
        }
    }, 200, [
        'Content-Type' => 'text/event-stream',
        'Cache-Control' => 'no-cache',
        'X-Accel-Buffering' => 'no',
    ]);
}
```

**前端**：
```typescript
const pollImportProgress = (importId: string) => {
  const eventSource = new EventSource(`/api/subscribers/import-progress/${importId}/stream`)
  
  eventSource.onmessage = (event) => {
    const progress = JSON.parse(event.data)
    setUploadProgress(progress.progress || 0)
    
    if (progress.status === 'completed') {
      eventSource.close()
      setIsUploading(false)
      // 更新结果...
    }
  }
  
  eventSource.onerror = (error) => {
    console.error('SSE错误:', error)
    eventSource.close()
    setIsUploading(false)
  }
}
```

---

## 📊 性能对比

| 方案 | 3分钟导入的请求数 | 服务器负载 | 实现难度 |
|------|------------------|-----------|---------|
| **原方案** (1秒轮询) | 180个 | 高 | 简单 |
| **方案1** (3秒轮询) | 60个 | 中 | 简单 ✅ |
| 动态轮询 | 40-50个 | 中低 | 中等 |
| 请求取消 | 60个 | 低 | 中等 |
| SSE推送 | 1个连接 | 低 | 复杂 |

---

## 🚀 部署步骤

### 1. 拉取最新代码
```bash
cd /data/www/sendwalk
git pull
```

### 2. 重新构建前端
```bash
cd frontend
npm run build
cd ..
```

### 3. 清理缓存
```bash
# 清理浏览器缓存
# Ctrl+F5 或 Cmd+Shift+R
```

### 4. （可选）调整PHP-FPM配置
```bash
# 编辑配置
sudo nano /etc/php/8.2/fpm/pool.d/www.conf

# 修改 pm.max_children 等参数

# 重启PHP-FPM
sudo systemctl restart php8.2-fpm
```

---

## 🔍 监控和诊断

### 1. 查看PHP-FPM状态
```bash
# 检查进程数
ps aux | grep php-fpm | wc -l

# 查看状态页（需要在Nginx中配置）
curl http://localhost/php-fpm-status

# 查看慢日志
sudo tail -f /var/log/php8.2-fpm.log
```

### 2. 查看Nginx状态
```bash
# 查看连接数
netstat -an | grep :80 | wc -l

# 查看错误日志
sudo tail -f /var/log/nginx/error.log

# 查看访问日志
sudo tail -f /var/log/nginx/access.log
```

### 3. 监控系统资源
```bash
# 实时监控
htop

# 查看内存使用
free -h

# 查看CPU负载
uptime
```

---

## 📝 最佳实践

### 1. **轮询间隔选择**
- **快速任务**（< 10秒）：1-2秒
- **中等任务**（10秒-1分钟）：2-3秒
- **长时间任务**（> 1分钟）：3-5秒

### 2. **避免请求堆积**
- 使用 AbortController 取消未完成的请求
- 添加请求超时机制
- 在组件卸载时清理定时器

### 3. **用户体验**
- 显示清晰的进度条
- 提供取消导入的选项
- 显示预估剩余时间

### 4. **错误处理**
- 设置最大轮询次数（如300次）
- 超时后提示用户刷新
- 记录错误日志便于排查

---

## ⚠️ 注意事项

1. **不要降得太低**
   - 轮询间隔太长会导致用户体验差
   - 建议不要超过5秒

2. **考虑并发导入**
   - 如果多个用户同时导入，请求数会倍增
   - 需要确保服务器资源充足

3. **数据库连接池**
   - 确保数据库最大连接数足够
   - Laravel默认：`DB_CONNECTION_LIMIT`

4. **队列worker数量**
   - 确保有足够的队列worker处理导入任务
   - Supervisor配置：`numprocs=3`

---

**更新日期**: 2025-12-26  
**版本**: v1.0  
**优化内容**: 将轮询间隔从1秒改为3秒，减少67%的请求数量

